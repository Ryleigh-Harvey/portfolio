# -*- coding: utf-8 -*-
"""Final Project

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1itZcSqLK3cZ4J4a-l-oEuvHbr5ALzBpk

### Machine Learning project:
#### James Maduako and Ryleigh Harvey

# Gender Definition Project:

**Introduction**

In today's age, social media platforms serve as a repository of human expression, revealing patterns in how individuals communicate. This project seeks to explore the relationship between language use and gender identity, specifically using Twitter data. The primary objective is to gauge a person's gender based on their manner of speech, employing various NPL techniques. By analyzing text data from Twitter, we aim to identify lingustic patterns that correlate with gender, utilizing methods such as sentiment analysis and text classification.

Given the complexities, surrounding gender identity, our apporoach acknowledges the limitations of traditional binary classification. So, we seek to highlight the nuances in language that may inform our understanding of gender expression in digital communication.
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# from google.colab import drive
# import nltk
# import pandas as pd
# nltk.download('all')
# drive.mount('/content/drive')
# twitter = pd.read_csv('/content/drive/My Drive/Colab Notebooks/Data/training.1600000.processed.noemoticon[1].csv', nrows=9000, header = 0,encoding='latin-1')
# sentimentd = pd.read_csv('/content/drive/My Drive/Colab Notebooks/Data/sentimentdataset.csv')
# survey = pd.read_csv('/content/drive/My Drive/Colab Notebooks/Data/Responses.csv')

text = 'Hi, my name is James and I am endlesssly bored of life and of living. Do you want to build a snowman. I am so distraught.'
from nltk.corpus import names
#sentimentd.head()
new_columns = ['Target', 'ID','Date','Flag','User','Text']
twitter.columns = new_columns
twitter.head()

"""#### Name-based Classification
First, we will begin by adding a new column to our dataset that will indicate the gender of users based on a predefined dataset/list of male and female names.
By comparing the user names with the male and femaile names given, we cna assign gender labels to the users allowing for a more nuanced analysis of their langauge pattern.

While this method provides a quick way to label a significant portion of the data, it also introduces inacuuracies due to the fact that many usernames do not clearly indicate gender, and some can be ambiguous.

"""

labeled_names = ([(name, 'male') for name in names.words('male.txt')]+
             [(name, 'female') for name in names.words('female.txt')])
print(labeled_names)

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# male_names = list(names.words('male.txt'))
# female_names = list(names.words('female.txt'))
# males = [x.lower() for x in male_names]
# females = [x.lower() for x in female_names]
# new_data = twitter
# new_data['gender'] = 0
# 
# for i in range(len(new_data.User)):
#   for x in males:
#       if x in new_data.User[i]:
#         new_data['gender'][i] = 'male'
#         print(i)
# 
# for i in range(len(new_data.User)):
#   for x in females:
#       if x in new_data.User[i]:
#         new_data['gender'][i] = 'female'
#         #print(f" {x} is in {new_data.User[i]}")

print(len(new_data[new_data.gender == 'male']))

print(len(new_data[new_data.gender == 'female']))

print(len(new_data[new_data.gender == 0]))

"""**Text Analysis**

By generating a list of words for male and female text , we have a visual representation of frequency of language use. This helps use identify common terms and phrases associated with each gender, giving insight on communication styles. It also helps to eliminate similar occurrences of words to create more variety.
"""

from wordcloud import WordCloud
import matplotlib.pyplot as plt
from nltk.tokenize import RegexpTokenizer
from nltk.corpus import stopwords

stopws = stopwords.words('english')
stopws.append('spam , @ , -')  # add any words you don't like to the list

tokenizer = RegexpTokenizer(r'\w+')
tokens = tokenizer.tokenize(text)
tokens = [token for token in tokens if token not in stopws]

new_males = new_data[new_data.gender == 'male']
male_texts=  textt = " ".join(review for review in new_males.Text)

#tokens = tokenizer.tokenize(text)
#tokens = [token for token in tokens if token not in stopws]

wordcloud = WordCloud(stopwords=stopws).generate(male_texts) #takes a while to generate
plt.imshow(wordcloud, interpolation='bilinear')
plt.axis("off")
plt.savefig('wordcloud11.png')
plt.show()

new_females = new_data[new_data.gender == 'female']
female_texts=  " ".join(review for review in new_females.Text)

wordcloud = WordCloud(stopwords=stopws).generate(female_texts) #takes a while to generate
plt.imshow(wordcloud, interpolation='bilinear')
plt.axis("off")
plt.savefig('wordcloud12.png')
plt.show()

"""### Word Sorting
We created a Wordcloud to visualize the frequency of words used by females and males. This allows us to easily identify common words shared by both genders, which we may want to filter out in our analysis, and it also provides insights into the unique vocabulary associated with each group.  The word cloud gives us  a way to discern patterns and themes that are prevalent in the language of each gender, helping us refine our approach to constructing a tailored bag of words.


"""

stopws.extend(["day", "I'm","work","today",'get',"still","going","go","got"])
wordcloud = WordCloud(stopwords=stopws).generate(male_texts) #takes a while to generate
plt.imshow(wordcloud, interpolation='bilinear')
plt.axis("off")
plt.savefig('wordcloud13.png')
plt.show()

wordcloud = WordCloud(stopwords=stopws).generate(female_texts) #takes a while to generate
plt.imshow(wordcloud, interpolation='bilinear')
plt.axis("off")
plt.savefig('wordcloud14.png')
plt.show()

"""### Punctuation

Our examination of punctuation frequency revealed potential differences in communication styles. Males and females may express emotions or reactions differently, a finding that could be explored further in future analyses.
"""

import matplotlib.pyplot as plt
import string
#Function to count punctuation in text
def count_punct(text):
  count = {punct: 0 for punct in string.punctuation}
  for char in text:
      if char in count:
        count[char] += 1
  return count

#count punctuation for male texts
male_punct_counts = count_punct(male_texts)
#count punctuation for female texts
female_punct_counts = count_punct(female_texts)

#create bar graph
bar_width= 0.35
x = range(len(punctuation))
plt.bar(x, male_punct_counts, width=bar_width, color='blue', label='Male', alpha=0.7)
plt.bar([i + bar_width for i in x], female_punct_counts, width=bar_width, color='red', label='Female', alpha=0.7)
plt.xlabel("Punctuation")
plt.ylabel("Frequency")
plt.title("Frequency of Punctuation in Male and Female Texts")
plt.xticks([i + bar_width / 2 for i in x], punctuation)
plt.legend()
plt.show()

def remove_unecessarys(text):
    final = "".join(u for u in text if u not in ("?", ".", ";", ":",'"',"day", "I'm","work","today",'get',"still","going","go","got","@","-"))
    return final
new_males['Text'] = new_males['Text'].apply(remove_unecessarys)
male_texts= new_males.Text
new_females['Text'] = new_females['Text'].apply(remove_unecessarys)
female_texts= new_females.Text
manual_stopwords = set([
    'i', 'me', 'my', 'myself', 'we', 'our', 'ours', 'ourselves', 'you', "you're", "you've",
    "you'll", "you'd", 'your', 'yours', 'yourself', 'yourselves', 'he', 'him', 'his', 'himself',
    'she', "she's", 'her', 'hers', 'herself', 'it', "it's", 'its', 'itself', 'they', 'them',
    'their', 'theirs', 'themselves', 'what', 'which', 'who', 'whom', 'this', 'that', "that'll",
    'these', 'those', 'am', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has',
    'had', 'having', 'do', 'does', 'did', 'doing', 'a', 'an', 'the', 'and', 'but', 'if', 'or',
    'because', 'as', 'until', 'while', 'of', 'at', 'by', 'for', 'with', 'about', 'against',
    'between', 'into', 'through', 'during', 'before', 'after', 'above', 'below', 'to', 'from',
    'up', 'down', 'in', 'out', 'on', 'off', 'over', 'under', 'again', 'further', 'then', 'once'
])

def preprocess_text_manual(text):
    # Remove non-alphabetic characters and convert to lowercase
    text = re.sub(r'[^a-zA-Z\s]', '', text).lower()
    # Tokenize by splitting
    words = text.split()
    # Remove stopwords using the manual list
    words = [word for word in words if word not in manual_stopwords]
    return words

"""### Classification and Predictions
Next, we will focus on refining our datasets by filtering out unnecessary columns and concatenating the male and female datasets into a unified format. Additionally, we plan to create a null dataset that lacks specific gender assignments. This dataset will serve a dual purpose: it will help streamline our analysis and provide a foundation for exploring gender prediction in future stages of our project. By implementing these steps, we aim to enhance the overall efficiency and effectiveness of our data processing, paving the way for more sophisticated analyses down the line.

"""

frames = [new_females,new_males]
merge_data = pd.concat(frames)
null_gender  = new_data[new_data.gender == 0]

final_data = merge_data[['Text','gender']]
null_data = null_gender[['Text', 'gender']]
final_data.tail()
final_data.to_csv('raw_data.csv', index=False)

from collections import Counter
import re
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score

male_words = [word for text in male_texts for word in preprocess_text_manual(text)]
female_words = [word for text in female_texts for word in preprocess_text_manual(text)]

male_bow = Counter(male_words)
female_bow = Counter(female_words)

print("Male Bag of Words (Top 10):", male_bow.most_common(10))
print("Female Bag of Words (Top 10):", female_bow.most_common(10))

"""### Training and Testing the Data"""

# Train-Test Split
X = final_data['Text']  # The text (features)
y = final_data['gender']  # The labels (male or female)

# Split the data into training and testing sets (80% training, 20% testing)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Convert text into bag-of-words (BoW) using CountVectorizer
vectorizer = CountVectorizer(stop_words=list(manual_stopwords))
X_train_bow = vectorizer.fit_transform(X_train)
X_test_bow = vectorizer.transform(X_test)

# Train a Logistic Regression model
model = LogisticRegression()
model.fit(X_train_bow, y_train)

# Make predictions on the test set
y_pred = model.predict(X_test_bow)

# Evaluate the model
accuracy = accuracy_score(y_test, y_pred)
print("Accuracy:", accuracy)

"""### Testing
We are now going to test our model with some random text to predict the gender of who sent the text. This text by no means is written by any specific gender, it is just a means to test if the model can at least predict a value. For further and more accurate testings, me and my partner are going to take various texts from twitter users whose gender we are aware of and see if our model can predict it, but that is for future and not present developments.
"""

# Function to test the model on a random text
def predict_gender(text, vectorizer, model):
    # Preprocess the text (you can add more preprocessing if needed)
    preprocessed_text = preprocess_text_manual(text)
    preprocessed_text = ' '.join(preprocessed_text)  # Join the list of words back into a string

    # Convert the text to a bag-of-words format (using the fitted vectorizer)
    text_bow = vectorizer.transform([preprocessed_text])

    # Predict the gender
    predicted_gender = model.predict(text_bow)

    return predicted_gender[0]

# Example of testing the model with a random text
random_text = "I really enjoyed the movie last night!"
predicted_gender = predict_gender(random_text, vectorizer, model)

print(f"The predicted gender for the text '{random_text}' is: {predicted_gender}")
predicted_gender = []
for i in survey.Q2:
  val = predict_gender(i, vectorizer, model)
  predicted_gender.append(val)
for i in predicted_gender:
  print(i)

"""### Conclusion
Predicting gender based on language is a highly complex and nuanced task, and we cannot claim to achieve accurate predictions at this stage. Our project focused on a few initial steps to approach this substantial challenge. Looking ahead, one significant improvement would be to utilize a larger portion of the dataset, rather than relying on the limited sample of 9,000 entries. In addition to refining our bag of words approach, I would explore the incorporation of specific phrases as features to enhance the modelâ€™s capability. There is considerable potential for improvement, and our findings have underscored both the challenges and intricacies involved in predicting gender through speech and language patterns. Overall, this project has provided valuable insights and has laid the groundwork for future exploration in this fascinating area of study.

"""